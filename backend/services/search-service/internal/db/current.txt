package db

import (
	"database/sql"
	"fmt"
	"strings"

	"github.com/jordyob03/TripTailor/backend/services/search-service/internal/models"
	"github.com/lib/pq"
)

func parseCommaSeparatedParam(param string) []string {
	if param == "" {
		return []string{}
	}
	return strings.Split(param, ",")
}

func prepareTagArray(tagString string) []string {
	// Split the string into individual tags
	return strings.Split(tagString, ",")
}

// Helper function to format an array of strings for SQL
func formatArrayForSQL(arr []string) string {
	// Debugging: Print the input to confirm the contents
	fmt.Printf("Input to formatArrayForSQL: %v\n", arr)

	// Format each element with single quotes
	quoted := make([]string, len(arr))
	for i, v := range arr {
		quoted[i] = fmt.Sprintf("'%s'", v)
	}

	// Join elements as a PostgreSQL array
	result := fmt.Sprintf("ARRAY[%s]::text[]", strings.Join(quoted, ","))

	// Debugging: Print the formatted result to verify output
	fmt.Printf("Formatted SQL array: %s\n", result)

	return result
}

// QueryItineraries builds a dynamic SQL query based on provided parameters
func QueryItineraries(db *sql.DB, params map[string]interface{}) ([]models.Itinerary, error) {
	baseQuery := `
		SELECT itineraryid, name, city, country, languages, tags, events, postid, username, creationdate, lastupdate
		FROM itineraries
		WHERE 1=1
	`

	inputString := "food,sushi"
	inputArray := strings.Split(inputString, ",")
	formattedArray := formatArrayForSQL(inputArray)
	fmt.Printf("format arrau result test: %s\n", formattedArray)

	var conditions []string
	var args []interface{}
	argCounter := 1

	// Dynamically build query conditions
	for key, value := range params {
		switch key {
		case "username", "country", "city":
			if v, ok := value.(string); ok && v != "" {
				conditions = append(conditions, fmt.Sprintf("%s = $%d", key, argCounter))
				args = append(args, v)
				argCounter++
			}
		case "tags":
			if tagArray, ok := value.([]string); ok && len(tagArray) > 0 {
				// Directly embed formatted tags array into the query
				fmt.Printf("arrau result before format: %s\n", tagArray)
				fmt.Printf("format arrau result before appending to query: %s\n", formatArrayForSQL(tagArray))
				tagArray := prepareTagArray(tagArray[0])
				conditions = append(conditions, fmt.Sprintf("tags && %s", formatArrayForSQL(tagArray)))
			}
		case "languages":
			if langArray, ok := value.([]string); ok && len(langArray) > 0 {
				// Directly embed formatted languages array into the query
				langArray := prepareTagArray(langArray[0])
				conditions = append(conditions, fmt.Sprintf("languages && %s", formatArrayForSQL(langArray)))
			}
		}
	}

	// Combine base query with dynamically built conditions
	query := baseQuery + " AND " + strings.Join(conditions, " AND ")

	// Print the final query and arguments for debugging
	fmt.Printf("Final Query: %s\n", query)
	fmt.Printf("Query Args: %+v\n", args)

	// Prepare and execute the query
	stmt, err := db.Prepare(query)
	if err != nil {
		return nil, fmt.Errorf("failed to prepare statement: %w", err)
	}
	defer stmt.Close()

	rows, err := stmt.Query(args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	// Process results
	var itineraries []models.Itinerary
	for rows.Next() {
		var itinerary models.Itinerary
		if err := rows.Scan(
			&itinerary.ItineraryId, &itinerary.Name, &itinerary.City, &itinerary.Country,
			pq.Array(&itinerary.Languages), pq.Array(&itinerary.Tags), pq.Array(&itinerary.Events),
			&itinerary.PostId, &itinerary.Username, &itinerary.CreationDate, &itinerary.LastUpdate,
		); err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}
		itineraries = append(itineraries, itinerary)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("row iteration error: %w", err)
	}

	return itineraries, nil
}

search.go

package handlers

import (
	"database/sql"
	"net/http"
	//"strconv"

	db "github.com/jordyob03/TripTailor/backend/services/search-service/internal/db" // Import from internal/db

	"github.com/gin-gonic/gin"
)

// SearchItineraries handles search requests with optional filters
func SearchItineraries(dbConn *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Collect query parameters dynamically
		params := map[string]interface{}{}

		// Add parameters only if they are present in the request
		if username := c.Query("username"); username != "" {
			params["username"] = username
		}
		if country := c.Query("country"); country != "" {
			params["country"] = country
		}
		if city := c.Query("city"); city != "" {
			params["city"] = city
		}
		if tags := c.QueryArray("tags"); len(tags) > 0 {
			params["tags"] = tags
		}
		if languages := c.QueryArray("languages"); len(languages) > 0 {
			params["languages"] = languages
		}

		// If no parameters are provided, return an error
		if len(params) == 0 {
			c.JSON(http.StatusBadRequest, gin.H{"error": "No query parameters provided"})
			return
		}

		// Query the database using the dynamic parameters
		itineraries, err := db.QueryItineraries(dbConn, params)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		// Return the results as JSON
		c.JSON(http.StatusOK, itineraries)
	}
}


Maybe useful:
for key, value := range params {
	switch key {
	case "tags":
		if tagArray, ok := value.([]string); ok && len(tagArray) > 0 {
			conditions = append(conditions, fmt.Sprintf("tags && %s", formatArrayForSQL(tagArray)))
		}
	case "languages":
		if langArray, ok := value.([]string); ok && len(langArray) > 0 {
			conditions = append(conditions, fmt.Sprintf("languages && %s", formatArrayForSQL(langArray)))
		}
	case "city", "country", "username":
		if v, ok := value.(string); ok && v != "" {
			conditions = append(conditions, fmt.Sprintf("%s = '%s'", key, v))
		}
	}
}